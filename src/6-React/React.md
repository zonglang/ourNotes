# React

### 设计思想

整个React应用就是一个状态机，状态驱动视图

```
view = f(data)

view是视图
state是数据（状态）
f是组件
```

### 具体实现

```
JSX =(creatElement)=> React Element ==> 虚拟DOM节点 =(diff)=> 真实DOM节点
```

### 函数式思想

```
1. UI可预测：同样的f输入同样的data，一定得到同样的view
2. 组件组合质量高： 函数式中有高阶函数的思想，React也有高阶组件
3. 数据驱动视图：专注于业务逻辑处理
```

### React的虚拟dom

```
1. 虚拟DOM的形式
   使用JS对象，对真实DOM进行抽象
2. 有什么作用
   更加关注与业务逻辑，而非DOM操作
   使用Diff算法和批处理策略提高开发效率
   跨平台能力，根据VirtualDOM，在不同平台使用不同方式绘制UI
3. 注意
   首次渲染，VirtualDOM不存在优势
   diff的DOM操作并非最优(追求高效的平衡)
```

### 单向数据流

```
1. 瀑布模型
   把state看作是水源，props看作是管道，数据是水流；
   数据只会通过props往子组件传递，每次state改变，数据会重新从state开始沿着props往子组件传递一遍；
   把这个想明白了，就能理解组件什么时候re-render。
2. 反向数据通道
   父组件定义一个能够改变state的回调，并把这个回调函数作为子组件的props传递下去。
   当子组件中调用这个回调函数改变父组件state之后，React的瀑布流又会更新所有子组件。
```

### 数据绑定（响应式）

React实际上是通过构建VirtualDOM进行数据绑定的，与Vue来个对比

| 名称  | 依赖收集 | 监听变化 |            监听变化             |
| :---: | :------: | :------: | :-----------------------------: |
|  Vue  | 数据劫持 |  getter  |    setter通知变化，更新视图     |
| React | 虚拟DOM  | 几乎没有 | setState通知变化，更新虚拟DOM树 |

细粒度的依赖收集是精确更新DOM的基础，无需做**额外的猜测和判断**，

从这个角度上看，Vue的视图更新更简单，相当于给每个组件都默认配置了`shouldComponentUpdate`，

（但是，那些牛人才不会在乎这么点组件优化带来的心智负担，他们喜欢的是React的一切皆为javascript，React的高度灵活，React从从`html / 模版`中解脱出来的自由奔放～）