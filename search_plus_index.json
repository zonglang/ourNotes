{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"2-css基础/css动画.html":{"url":"2-css基础/css动画.html","title":"css transition","keywords":"","body":"css transition 这是一个过渡的概念 指定属性 指定动画时间 指定延时时间 指定变化曲线 缺点：需要时间触发，一次性的不能自动重复，没有中间状态 css animation 指定周期 指定动画名称（@keyframes关键字定义） css transform 旋转、缩放、倾斜、平移给定元素 translate3d、rotate3d开启GPU硬件加速 "},"4-网络相关/DNS.html":{"url":"4-网络相关/DNS.html","title":"DNS","keywords":"","body":"DNS 作用：完成主机名到IP地址的转换 查询方式 递归查询(收到准确答复) 迭代查询(收到下一个请求地址) 使用UDP，53端口 DNS劫持：修改域名解析的结果 DNS污染：通往国外的网关上 // 回答模版 1. 起源：tcp/ip基于IP地址，只能识别网络通讯时只能识别IP地址，所以需要DNS解析 2. 过程：浏览器缓存 => 系统缓存 => 路由器缓存 => ISP的DNS缓存 => 从根域名服务器开始查询 3. 方式： 递归迭代 4. 作用：DNS劫持、污染 5. 前端相关： 'dns-prefetch' 预解析 meta信息声明，link标签指定预解析 域名分散处理 解决浏览器并发连接数问题 解决cookie污染问题 浏览器限制同域并发请求 页面渲染 DOM树的构建是从接受到文档开始的，先将字节转化为字符，然后字符转化为标记，接着标记构建dom树。这个过程被分为标记化和树构建 而这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。 css加载 知乎上的一个实验 不会阻塞DOM树的解析. DOM树和CSSDOM树不在一个线程 会阻塞DOM树的渲染, render tree的构建需要CSSDOM tree 会阻塞后面的JS执行， JS 执行可能要获取css信息 三个过程会有交叉地进行 加载 ==》 加载html，css，js 解析 ==》 构建DOM tree、CSSDOM tree、执行JS 渲染 ==》 渲染render tree 小结 css加载和解析，会阻塞JS，渲染 js加载和解析，会阻塞所有 async，加载不阻塞，执行会阻塞所有，==异步执行== defer，加载和执行都不阻塞，执行会在所有元素解析之后完成，==同步执行== "},"6-React/React.html":{"url":"6-React/React.html","title":"React","keywords":"","body":"React 设计思想 整个React应用就是一个状态机，状态驱动视图 view = f(data) view是视图 state是数据（状态） f是组件 具体实现 JSX =(creatElement)=> React Element ==> 虚拟DOM节点 =(diff)=> 真实DOM节点 函数式思想 1. UI可预测：同样的f输入同样的data，一定得到同样的view 2. 组件组合质量高： 函数式中有高阶函数的思想，React也有高阶组件 3. 数据驱动视图：专注于业务逻辑处理 React的虚拟dom 1. 虚拟DOM的形式 使用JS对象，对真实DOM进行抽象 2. 有什么作用 更加关注与业务逻辑，而非DOM操作 使用Diff算法和批处理策略提高开发效率 跨平台能力，根据VirtualDOM，在不同平台使用不同方式绘制UI 3. 注意 首次渲染，VirtualDOM不存在优势 diff的DOM操作并非最优(追求高效的平衡) 单向数据流 1. 瀑布模型 把state看作是水源，props看作是管道，数据是水流； 数据只会通过props往子组件传递，每次state改变，数据会重新从state开始沿着props往子组件传递一遍； 把这个想明白了，就能理解组件什么时候re-render。 2. 反向数据通道 父组件定义一个能够改变state的回调，并把这个回调函数作为子组件的props传递下去。 当子组件中调用这个回调函数改变父组件state之后，React的瀑布流又会更新所有子组件。 数据绑定（响应式） React实际上是通过构建VirtualDOM进行数据绑定的，与Vue来个对比 名称 依赖收集 监听变化 监听变化 Vue 数据劫持 getter setter通知变化，更新视图 React 虚拟DOM 几乎没有 setState通知变化，更新虚拟DOM树 细粒度的依赖收集是精确更新DOM的基础，无需做额外的猜测和判断， 从这个角度上看，Vue的视图更新更简单，相当于给每个组件都默认配置了shouldComponentUpdate， （但是，那些牛人才不会在乎这么点组件优化带来的心智负担，他们喜欢的是React的一切皆为javascript，React的高度灵活，React从从html / 模版中解脱出来的自由奔放～） "}}